#+TITLE:       Publishing Script
#+DESCRIPTION: The publishing script that creates this website
#+DATE:        <2024-06-02>
#+IMAGE:
#+TAGS[]:      lisp
#+OPTIONS:     toc:nil num:nil

#+CALL: ~/dev/andersch.dev/code.org:generate-article-header[:eval yes]()
* {{{TITLE}}}
#+CALL: ~/dev/andersch.dev/code.org:generate-article-subtitle[:eval yes]()

This file is the template for the ~publish.el~ publishing script.

# endsnippet

** Packages
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../publish.el
;; set package install dir to local directory
(require 'package)
(setq package-user-dir (expand-file-name "./.packages"))
(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("elpa" . "https://elpa.gnu.org/packages/")
                         ("nongnu" . "https://elpa.nongnu.org/nongnu/")))
(package-initialize)
(unless package-archive-contents (package-refresh-contents))
#+END_SRC

** Dependencies
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../publish.el
(package-install 'htmlize) ; enable export of #+begin_src code blocks
(require 'ox-publish)
(require 'org)
(require 'cl-lib)
(package-install 'org-contrib) ; for ox-extra
(require 'ox-extra) ; for :IGNORE: headlines
(ox-extras-activate '(latex-header-blocks ignore-headlines))

(require 'ob-emacs-lisp)
#+END_SRC

** Configuration
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../publish.el
(setq
      keywords '("TITLE" "DATE" "DESCRIPTION" "IMAGE" "TAGS[]") ; keywords to parse from .org files
      org-html-htmlize-output-type 'css
      org-src-fontify-natively t)
#+END_SRC

** Helper functions
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../publish.el
(defun get-org-files (directory)
  "Return a list of .org files in DIRECTORY excluding 'index.org'."
  (cl-remove-if
   (lambda (file) (string-equal (concat directory "/" "index.org") file))
   (directory-files-recursively directory "\\.org$")))
(defun get-org-file-keywords (file)
  (with-temp-buffer
    (insert-file-contents file)
    ;(org-mode)
    (list file (org-collect-keywords keywords))))
(defun sort-keyword-list-by-date (keyword-list &optional new-to-old)
  "Sort the list by the date value of the form <YYYY-MM-DD HH:MM>"
  (sort keyword-list
        (lambda (a b)
          (let* ((date-str-a (replace-regexp-in-string "<\\[\\]>" "" (cadr (assoc "DATE" (cadr a)))))
                 (date-str-b (replace-regexp-in-string "<\\[\\]>" "" (cadr (assoc "DATE" (cadr b))))))
            (if new-to-old
              (string> date-str-a date-str-b)
              (string< date-str-a date-str-b))))))
(defun article-marked-for-noexport-p (article)
  (string-match-p (regexp-quote "noexport") (cadr (assoc "TAGS[]" (cadr article)))))
#+END_SRC

** State
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../publish.el
; TODO put together
(setq article-keyword-list '())
(setq project-keyword-list '())
(setq other-keyword-list   '())
#+END_SRC

** Filter function
Replace links to e.g. ~"article/index.html"~ to just ~"article"~.

#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../publish.el
(defun filter-out-index-html (transcoded-data-string backend communication-channel-plist)
  (when (org-export-derived-backend-p backend 'html)
    (replace-regexp-in-string "/index.html" "" transcoded-data-string)
  ))

(add-to-list 'org-export-filter-link-functions 'filter-out-index-html)
#+END_SRC

** Prepare publishing function
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../publish.el
(defun prepare-publishing (project-properties)
  ;
  ; FILL & SORT KEYWORD-LISTS FOR PROJECT/, ARTICLE/, OTHER/
  ;
  (dolist (article (get-org-files "article"))
    (let ((article-keywords (get-org-file-keywords article)))
      (unless (article-marked-for-noexport-p article-keywords)
        (push (get-org-file-keywords article) article-keyword-list))))
  (setq article-keyword-list (sort-keyword-list-by-date article-keyword-list t))

  (dolist (project (get-org-files "project"))
    (let ((project-keywords (get-org-file-keywords project)))
      (unless (article-marked-for-noexport-p project-keywords)
        (push (get-org-file-keywords project) project-keyword-list))))
  (setq project-keyword-list (sort-keyword-list-by-date project-keyword-list t))

  (dolist (other (get-org-files "other"))
    (let ((other-keywords (get-org-file-keywords other)))
      (unless (article-marked-for-noexport-p other-keywords)
        (push (get-org-file-keywords other) other-keyword-list))))
  (setq other-keyword-list (sort-keyword-list-by-date other-keyword-list t))

  ;
  ; GENERATE RSS FEED FOR ARTICLES
  ;
  ; rss header, check with  https://validator.w3.org/feed/
  (with-temp-file "feed.rss"
    (insert
     (let* ((website-title "andersch.dev")
            (homepage      "https://andersch.dev")
            (rss-filepath  "/feed.rss"))
     (concat "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
             "<rss version=\"2.0\" xmlns:atom=\"http://www.w3.org/2005/Atom\">\n"
             "<channel>\n"
             (format "<title>%s</title>\n" website-title)
             "<!-- <lastBuildDate>Wed, 15 Dec 2021 00:00:00 +0000</lastBuildDate> -->\n" ; TODO insert todays date
             (format "<atom:link href=\"%s%s\" rel=\"self\" type=\"application/rss+xml\"/>\n" homepage rss-filepath)
             (format "<link>%s/index.html</link>\n" homepage)
             "<description>Stuff on programming</description>\n"
             "<language>en-us</language>\n"))))
  ; rss entries
  (dolist (article article-keyword-list)
    (write-region
      (format
         (concat "<item>\n"
                 "<title>%s</title>\n"
                 "<link>%s</link>\n"
                 "<guid>%s</guid>\n"
                 "<description>\n"
                 "&lt;p&gt;%s&lt;/p&gt;\n"
                 "&lt;img src=\"https://andersch.dev/article/%s\"/&gt;\n"
                 "</description>\n"
                 "<pubDate>%s</pubDate>\n</item>\n")
            (cadr (assoc "TITLE" (cadr article)))
            (concat "https://andersch.dev/" (string-replace ".org" ".html" (car article)))
            (concat "https://andersch.dev/" (string-replace ".org" ".html" (car article)))
            (cadr (assoc "DESCRIPTION" (cadr article)))
            (cadr (assoc "IMAGE" (cadr article)))
            (format-time-string "%a, %d %b %Y %H:%M:%S %z" (seconds-to-time (org-time-string-to-time (cadr (assoc "DATE" (cadr article))))))
            )
      nil "feed.rss" 'append))
  ; rss ending
  (write-region "</channel>\n</rss>" nil "feed.rss" 'append)

  ;
  ; EXECUTE NAMED SRC BLOCKS
  ;
  (dolist (org-file (directory-files-recursively "./" "\\.org$"))
      (find-file org-file)
      (setq src-block-names '("list-of-projects" "latest-article" "latest-project" "generate-tags"))
      (goto-char (point-min))
      (setq org-confirm-babel-evaluate nil) ; NOTE needed when org-babel-execute-src-block is called in a script
      (dolist (src-block-name src-block-names)
        (if (org-babel-find-named-block src-block-name)
          (progn
            (org-babel-goto-named-src-block src-block-name)
            (org-babel-execute-src-block))))
      (save-buffer)
      (kill-buffer))

  ;
  ; TAGGING SYSTEM
  ;
  ; collect all tags
  (setq all-tags '())
  (dolist (article article-keyword-list)
     (setq all-tags (append (split-string (cadr (assoc "TAGS[]" (cadr article)))  " +") all-tags)))
  (dolist (project project-keyword-list)
     (setq all-tags (append (split-string (cadr (assoc "TAGS[]" (cadr project)))  " +") all-tags)))
  (dolist (other other-keyword-list)
     (setq all-tags (append (split-string (cadr (assoc "TAGS[]" (cadr other)))  " +") all-tags)))
  (delete-dups all-tags)
  ; generate .org files for all tags
  (dolist (tag all-tags)
    (with-temp-file (format "tag/%s.org" tag)
      (insert (format "#+TITLE: Pages tagged %s\n" tag)))

  (write-region (format "* Articles tagged ~%s~\n" tag) nil (format "tag/%s.org" tag) 'append))
  ; add entry of an article to its tag.org's
  (dolist (article article-keyword-list)
    (dolist (tag (split-string (cadr (assoc "TAGS[]" (cadr article)))  " +"))
      (write-region (format "- [[../%s][%s]]\n"
                            (car article)
                            (cadr (assoc "TITLE" (cadr article))))
                    nil (format "tag/%s.org" tag) 'append)))

  ; append "* Projects" headline
  (dolist (tag all-tags)
    (write-region (format "* Projects tagged ~%s~\n" tag) nil (format "tag/%s.org" tag) 'append))
  ; add entry of a project to its tag.org's
  (dolist (project project-keyword-list)
    (dolist (tag (split-string (cadr (assoc "TAGS[]" (cadr project)))  " +"))
      (write-region (format "- [[../%s][%s]]\n"
                            (car project)
                            (cadr (assoc "TITLE" (cadr project))))
                    nil (format "tag/%s.org" tag) 'append)))

  ; append "* Projects" headline
  (dolist (tag all-tags)
    (write-region (format "* Other tagged ~%s~\n" tag) nil (format "tag/%s.org" tag) 'append))
  ; add entry of a project to its tag.org's
  (dolist (other other-keyword-list)
    (dolist (tag (split-string (cadr (assoc "TAGS[]" (cadr other)))  " +"))
      (write-region (format "- [[../%s][%s]]\n"
                            (car other)
                            (cadr (assoc "TITLE" (cadr other))))
                    nil (format "tag/%s.org" tag) 'append)))
)
#+END_SRC

** Org-publish Customization
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../publish.el
;; customize HTML output (see https://pank.eu/blog/blog-setup.html)
; see https://www.gnu.org/software/emacs/manual/html_node/org/Publishing-options.html
(setq org-publish-project-alist
      (list
       (list "andersch.dev"
             :recursive            t
             :base-directory       "./"
             :publishing-directory "./"
             :publishing-function  'org-html-publish-to-html ;; may be a list of functions
             :preparation-function 'prepare-publishing       ;; called before publishing
           ; :completion-function                            ;; called after
           ; :base-extension                                 ;; extension of source files
           ; :html-extension       ""                        ;; extension of generated html files
             :exclude "code.org"                 ;; regex of files to exclude NOTE excluding dirs seems to not work
           ; :include                                        ;; list of files to include
           ; :html-doctype "html5"                           ;; default is "xhtml-strict"
             :html-divs            '((preamble "header" "top")
                                     (content "main" "content")
                                     (postamble "footer" "postamble"))
             :html-html5-fancy     t
             :html-head            (concat "<title>andersch.dev</title>\n"
                                           "<link rel=\"icon\" type=\"image/x-icon\" href=\"/favicon.ico\">\n"
                                           "<link rel=\"stylesheet\" href=\"/style.css\">\n"
                                           ; NOTE import ubuntu font for now
                                           "<link rel=\"stylesheet\" type=\"text/css\" href=\"https://fonts.googleapis.com/css?family=Ubuntu:regular,bold&subset=Latin\">"
                                           )
             :html-preamble        t
             :html-preamble-format `(("en" ,(with-temp-buffer (insert-file-contents "header.html") (buffer-string))))
             :html-postamble       nil                       ;; don't insert a footer with a date etc.

             :auto-sitemap         t                         ;; https://orgmode.org/manual/Site-map.html
             :sitemap-filename     "sitemap.org"             ;; ...
           ; :sitemap-title
             :sitemap-style        'tree                     ;; list or tree
             :sitemap-sort-files   'anti-chronologically
           ; :makeindex t                                    ;; https://orgmode.org/manual/Generating-an-index.html
             :with-title           nil                       ;; we include our own header
             :with-author          nil
             :with-creator         nil                       ;; don't include emacs and org versions in footer
             :with-toc             nil                       ;; no table of contents
             :section-numbers      nil                       ;; no section numbers for headings
             :html-validation-link nil                       ;; don't show validation link
             :time-stamp-file      nil                       ;; don't include "Created: <timestamp>" in footer
             :with-date            nil)))
#+END_SRC

** Fix caching issue
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../publish.el
; NOTE caching causes problems with updating titles etc., so we reset the cache before publishing
(setq org-publish-use-timestamps-flag nil)
(setq org-publish-timestamp-directory "./.org-timestamps/")
(org-publish-remove-all-timestamps)
#+END_SRC

** Workaround
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../publish.el
; NOTE workaround to not get a "Symbolâ€™s function definition is void" error when publishing
(defun get-article-keyword-list () article-keyword-list) ; NOTE workaround to pass keyword-list to a source-block in an org file
(defun get-project-keyword-list () project-keyword-list) ; NOTE workaround to pass keyword-list to a source-block in an org file
(defun get-other-keyword-list   () other-keyword-list)   ; NOTE workaround to pass keyword-list to a source-block in an org file
#+END_SRC

** Build
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../publish.el
(org-publish "andersch.dev" t) ;; export html files
(message "Build complete")
#+END_SRC

** Code snippets
*** Generate Tags
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../code.org
,#+NAME: generate-tags
,#+BEGIN_SRC emacs-lisp :eval no :exports results :results html
(setq tags-string '())
;(if (eq org-export-current-backend 'html)
;  (progn
    ;(setq tags-string (append tags-string (list "#+BEGIN_EXPORT html\n")))
    (setq tags-string (append tags-string (list "<div class=\"tags\">")))
    (setq tags-string (append tags-string (list "[ ")))
    (setq tags (split-string (cadar (org-collect-keywords '("TAGS[]"))) " +"))
    (dolist (tag tags)
      (setq tags-string (append tags-string (list (format "<a href=\"/tag/%s.html\">%s</a> " tag tag))))
      )
    (setq tags-string (append tags-string (list "]")))
    (setq tags-string (append tags-string (list "</div>\n")))
    ;(setq tags-string (append tags-string (list "#+END_EXPORT")))
    (mapconcat #'identity tags-string "") ; flatten string list to a string
;  )
;  (print "")
;)
,#+END_SRC
#+END_SRc

*** Generate Article Header & Subtitle
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../code.org
,#+NAME: generate-article-header
,#+BEGIN_SRC emacs-lisp :eval no :exports results :results html
(defun generate-tags ()
  (setq tags-string '())
      (setq tags-string (append tags-string (list "<div class=\"tags\">")))
      (setq tags-string (append tags-string (list "<code>")))
      (setq tags-string (append tags-string (list "[ ")))
      (setq tags (split-string (cadar (org-collect-keywords '("TAGS[]"))) " +"))
      (dolist (tag tags)
        (setq tags-string (append tags-string (list (format "<a href=\"/tag/%s.html\">%s</a> " tag tag))))
        )
      (setq tags-string (append tags-string (list "]")))
      (setq tags-string (append tags-string (list "</code>")))
      (setq tags-string (append tags-string (list "</div>\n")))
      (mapconcat #'identity tags-string "")) ; flatten string list to a string

(setq keywords (org-collect-keywords '("TITLE" "DESCRIPTION" "DATE" "IMAGE" "TAGS[]")))

(format
   (concat
     "<div class=\"tags-date-box\">\n"
       (generate-tags)
       "<div class=\"date\"><span class=\"timestamp\">%s</span></div>\n"
     "</div>\n")
   (cadr (assoc "DATE" keywords)))
,#+END_SRC
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../code.org
,#+NAME: generate-article-subtitle
,#+BEGIN_SRC emacs-lisp :eval no :exports results :results html
(setq keywords (org-collect-keywords '("TITLE" "DESCRIPTION" "DATE" "IMAGE" "TAGS[]")))

; check if IMAGE is set
(if (string= "" (cadr (assoc "IMAGE" keywords)))
  (progn
    (setq image-fmt-string "%s")
    (setq image-path ""))
  (progn
    ; TODO hardcoded
    (setq image-path (string-replace "/index.org" "" (string-replace "/home/da/dev/andersch.dev/" "" (buffer-file-name))))
    (setq image-fmt-string "<div class=\"figure\"><img src=\"/%s/%s\" alt=\"\"></div>")))

(format
   (concat
     "<h2 class=\"subtitle\">%s</h1>"
     image-fmt-string)
   (cadr (assoc "DESCRIPTION" keywords))
   image-path
   (cadr (assoc "IMAGE" keywords)))
,#+END_SRC
#+END_SRC

*** Generate Article Snippets
#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../code.org
,#+NAME: generate-article-snippets
,#+BEGIN_SRC emacs-lisp :eval no :exports results :results html :var list='()
(setq article-snippets '())
(dolist (article list)
  (with-temp-buffer
    (insert-file-contents (concat "../" (car article)))

    ;; remove everything after the snippet marker
    (setq snippet-marker "# endsnippet")
    (if (search-forward snippet-marker nil t)
      (setq begin (point))
      (error (format "Snippet marker is not set for %s" (car article))))
    (end-of-buffer)
    (setq end (point))
    (goto-char (point-min))
    (delete-region begin end)

    ;; NOTE: otherwise (buffer-file-name) in generate-article-subtitle returns nil
    (set-visited-file-name (concat "../" (car article)))

    ;; export snippet as html
    (setq org-export-show-temporary-export-buffer nil)
    (org-html-export-as-html nil nil nil t nil)
    (switch-to-buffer "*Org HTML Export*")
    (setq article-snippets (append article-snippets (list (buffer-string))))

    ;; read more link
    (setq read-more-html (format "<div class=\"read-more\"><a href=\"/%s\">READ MORE</a></div>" (string-replace "/index.org" "" (car article))))
    (setq article-snippets (append article-snippets (list read-more-html)))

    ;; dividing line between snippets
    (setq article-snippets (append article-snippets (list "<hr>\n")))
  )
)

(mapconcat #'identity article-snippets "") ; flatten string list to a string
,#+END_SRC
#+END_SRC

*** List of articles
Unused

#+BEGIN_SRC emacs-lisp :tangle yes :tangle ../../code.org
,#+NAME: list-of-articles
,#+BEGIN_SRC emacs-lisp :eval no :exports results :results raw drawer :var list='()
(setq list-string '())
(if (eq org-export-current-backend 'html)
  (dolist (entry list)
    (push
     (format
       (concat
        "#+BEGIN_EXPORT html\n"
        "<div class=\"image-container\">\n"
           ; NOTE "../" as a workaround
           "<a href=\"../%s\">\n"
               "<div class=\"overlay\">\n"
                   "<div class=\"title\">%s</div>\n"
                   "<div class=\"description\">%s</div>\n"
               "</div>\n"
               "<img src=\"./%s\" alt=\"\">\n"
           "</a>\n"
        "</div>\n"
        "#+END_EXPORT\n")
       (string-replace ".org" ".html" (car entry))
       (cadr (assoc "TITLE" (cadr entry)))
       (cadr (assoc "DESCRIPTION" (cadr entry)))
       (cadr (assoc "IMAGE" (cadr entry))))
    list-string)
  )
  (dolist (entry list)
    ; NOTE "../" as a workaround
    (push (format "- [[../%s][%s]]" (car entry) (cadr (assoc "TITLE" (cadr entry)))) list-string)
  ))
(mapconcat #'identity list-string "\n") ; flatten string list to a string
,#+END_SRC
#+END_SRC
