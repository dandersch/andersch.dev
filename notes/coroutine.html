<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coroutine</title>
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<title>andersch.dev</title>
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel="stylesheet" href="/style.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Ubuntu:regular,bold&subset=Latin"><script type="text/javascript" src="/script.js" defer></script>
</head>
<body>
<header id="top" class="status">
<header>
<h1 class="title" id="title"><a href="/">andersch.dev</a></h1>

<div class="icons">
  	<a id="icon-github" href="https://github.com/dandersch" ><span>dandersch</span><img src="/icons/github.svg"></a>
  	<a id="icon-feed"   href="https://andersch.dev/feed.xml" target="_blank"><img src="/icons/rss.svg"><span></span></a>
  	<a id="icon-mail"   href="mailto:contact [at} andersch {dot) dev"  ><img src="/icons/mail.svg"><span>contact [at} andersch {dot) dev</span></a>
</div>
<div>
	<nav class="nav">
		<a class="nav-link" href="/article">article</a>
		<a class="nav-link" href="/project">project</a>
		<a class="nav-link" href="/other">other</a>
		<a class="nav-link" href="/notes">wiki</a>
	</nav>
</div>
</header>
</header>
<main id="content" class="content">
<h1 class="title">Coroutine</h1>
<p>
Coroutines are <i>"functions whose execution you can pause"</i>.
</p>

<p>
They can be symmetric or asymmetric. Symmetric coroutines have bidirectional
control flow: both caller and callee (i.e. the coroutine) can yield control to
each other. Asymmetric coroutines are the more common form: the caller invokes
the coroutine and it runs until it yields control back to the caller.
</p>

<p>
Coroutines can also be differentiated by their management of the call stack.
Stackful coroutines maintain their own call stack (meaning they can have local
variables), while stackless coroutines share the call stack of the caller.
</p>

<p>
They can be used to implement linear <a href="state_machine.html#ID-f6050ba4-2cde-4c10-89a1-dec39c2c20e0">state machines</a> in a straight-forward manner
(<i>"Co-routines are to state machines what recursion is to stacks"</i><sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>).
</p>
<div id="outline-container-org044b8ee" class="outline-2">
<h2 id="org044b8ee"><a href="#org044b8ee">Stackless Coroutines in C using Macros</a></h2>
<div class="outline-text-2" id="text-org044b8ee">
<p>
A form of Coroutines (more specifically, <a href="https://en.wikipedia.org/wiki/Protothread">Protothreads</a>) can be implemented in <a href="c.html#ID-3a2b1a06-f048-460c-9944-04b11d4fdbcd">C</a>
using <a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">Duff's Device</a>. This technique essentially works by saving the state of
where a Coroutine was previously yielded and using a switch statement to jump
back to that code (i.e. resuming the function).
</p>

<p>
This means the state for the coroutine is just an integer that keeps track of
its last line of code (which corresponds to a case label on the same line). This
integer is often called <code>index</code>, <code>line</code>, or <code>sequence point</code>.
</p>
</div>
<div id="outline-container-org3d7baf7" class="outline-3">
<h3 id="org3d7baf7"><a href="#org3d7baf7">Minimal Implementation</a></h3>
<div class="outline-text-3" id="text-org3d7baf7">
<p>
<a href="https://github.com/RandyGaul/kk_slides/blob/master/slides/coroutine.h">Minimal macro implementation</a>
</p>

<div class="org-src-container">
<pre class="src src-C" id="simple_coroutine"><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">coroutine_t</span> {
    <span class="org-type">int</span>   <span class="org-variable-name">index</span>;
    <span class="org-type">float</span> <span class="org-variable-name">elapsed</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">optional</span><span class="org-comment-delimiter"> */</span>
} <span class="org-type">coroutine_t</span>;

<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_START</span>(<span class="org-variable-name">co</span>)          <span class="org-keyword">do</span> { <span class="org-keyword">switch</span> (co-&gt;index)  { <span class="org-keyword">default</span>:
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_EXIT</span>(<span class="org-variable-name">co</span>)           <span class="org-keyword">do</span> { <span class="org-keyword">goto</span> <span class="org-constant">__co_end</span>; } <span class="org-keyword">while</span> (0)
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_YIELD</span>(<span class="org-variable-name">co</span>)          <span class="org-keyword">do</span> { co-&gt;index = __LINE__; COROUTINE_EXIT(co); <span class="org-keyword">case</span> __LINE__:; } <span class="org-keyword">while</span> (0)
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_END</span>(<span class="org-variable-name">co</span>)            } co-&gt;index = 0; <span class="org-constant">__co_end</span>:; } <span class="org-keyword">while</span> (0)

<span class="org-comment-delimiter">/* </span><span class="org-comment">useful macros</span><span class="org-comment-delimiter"> */</span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_WAIT</span>(<span class="org-variable-name">co</span>, <span class="org-variable-name">time</span>, <span class="org-variable-name">dt</span>) <span class="org-keyword">do</span> { <span class="org-keyword">case</span> __LINE__: co-&gt;index = __LINE__; co-&gt;elapsed += dt; <span class="org-keyword">do</span> { <span class="org-keyword">if</span> (co-&gt;elapsed &lt; time) { <span class="org-keyword">goto</span> <span class="org-constant">__co_end</span>; } <span class="org-keyword">else</span> { co-&gt;elapsed = 0; } } <span class="org-keyword">while</span> (0); } <span class="org-keyword">while</span> (0)
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_CASE</span>(<span class="org-variable-name">co</span>, <span class="org-variable-name">name</span>)     <span class="org-keyword">case</span> __LINE__: <span class="org-constant">name</span>: co-&gt;index = __LINE__;
</pre>
</div>

<p>
Usage code after macro expansion would look like this:
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">coroutine_t</span> {
    <span class="org-type">int</span>   <span class="org-variable-name">index</span>;
    <span class="org-type">float</span> <span class="org-variable-name">elapsed</span>; <span class="org-comment-delimiter">/* </span><span class="org-comment">optional</span><span class="org-comment-delimiter"> */</span>
} <span class="org-type">coroutine_t</span>;

<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_START</span>(<span class="org-variable-name">co</span>)          <span class="org-keyword">do</span> { <span class="org-keyword">switch</span> (co-&gt;index)  { <span class="org-keyword">default</span>:
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_EXIT</span>(<span class="org-variable-name">co</span>)           <span class="org-keyword">do</span> { <span class="org-keyword">goto</span> <span class="org-constant">__co_end</span>; } <span class="org-keyword">while</span> (0)
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_YIELD</span>(<span class="org-variable-name">co</span>)          <span class="org-keyword">do</span> { co-&gt;index = __LINE__; COROUTINE_EXIT(co); <span class="org-keyword">case</span> __LINE__:; } <span class="org-keyword">while</span> (0)
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_END</span>(<span class="org-variable-name">co</span>)            } co-&gt;index = 0; <span class="org-constant">__co_end</span>:; } <span class="org-keyword">while</span> (0)

<span class="org-comment-delimiter">/* </span><span class="org-comment">useful macros</span><span class="org-comment-delimiter"> */</span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_WAIT</span>(<span class="org-variable-name">co</span>, <span class="org-variable-name">time</span>, <span class="org-variable-name">dt</span>) <span class="org-keyword">do</span> { <span class="org-keyword">case</span> __LINE__: co-&gt;index = __LINE__; co-&gt;elapsed += dt; <span class="org-keyword">do</span> { <span class="org-keyword">if</span> (co-&gt;elapsed &lt; time) { <span class="org-keyword">goto</span> <span class="org-constant">__co_end</span>; } <span class="org-keyword">else</span> { co-&gt;elapsed = 0; } } <span class="org-keyword">while</span> (0); } <span class="org-keyword">while</span> (0)
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_CASE</span>(<span class="org-variable-name">co</span>, <span class="org-variable-name">name</span>)     <span class="org-keyword">case</span> __LINE__: <span class="org-constant">name</span>: co-&gt;index = __LINE__;
<span class="org-type">void</span> <span class="org-function-name">some_function</span>(<span class="org-type">coroutine_t</span>* <span class="org-variable-name">co</span>)
{
  <span class="org-keyword">switch</span> (co-&gt;index)  { <span class="org-keyword">default</span>:                               <span class="org-comment-delimiter">// </span><span class="org-comment">START</span>
    printf(<span class="org-string">"First\n"</span>);
    co-&gt;index = __LINE__; COROUTINE_EXIT(co); <span class="org-keyword">case</span> __LINE__:;  <span class="org-comment-delimiter">// </span><span class="org-comment">YIELD</span>
    printf(<span class="org-string">"Third\n"</span>);
  } co-&gt;index = 0; <span class="org-constant">__co_end</span>:;                                  <span class="org-comment-delimiter">// </span><span class="org-comment">END</span>
}

<span class="org-keyword">static</span> <span class="org-type">coroutine_t</span> <span class="org-variable-name">co</span>;
some_function(&amp;co);
printf(<span class="org-string">"Second\n"</span>);
some_function(&amp;co);
</pre>
</div>
</div>
</div>
<div id="outline-container-org7ebea58" class="outline-3">
<h3 id="org7ebea58"><a href="#org7ebea58"><span class="todo TODO">TODO</span> Macro Implementation without COROUTINE<sub>END</sub></a></h3>
<div class="outline-text-3" id="text-org7ebea58">
<p>
Implementation without having to specify COROUTINE<sub>END</sub>.
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">coroutine_t</span>
{
    <span class="org-type">float</span> <span class="org-variable-name">elapsed</span>;
    <span class="org-type">int</span>   <span class="org-variable-name">index</span>;
} <span class="org-type">coroutine_t</span>;

<span class="org-preprocessor">#define</span> <span class="org-function-name">coroutine</span>(<span class="org-variable-name">co</span>)  <span class="org-type">coroutine_t</span>* <span class="org-variable-name">_co</span> = co; <span class="org-keyword">switch</span> (_co-&gt;index) <span class="org-keyword">default</span>: <span class="org-keyword">if</span>(0) <span class="org-constant">_body</span>: <span class="org-keyword">break</span>; <span class="org-keyword">else</span> <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">_i_</span>##__LINE__ = (0); <span class="org-negation-char">!</span>_i_##__LINE__; (_i_##__LINE__ += 1), _co-&gt;index = 0)
<span class="org-preprocessor">#define</span> <span class="org-variable-name">yield</span>          _co-&gt;index = __LINE__; <span class="org-keyword">goto</span> <span class="org-constant">_body</span>; <span class="org-keyword">case</span> __LINE__:;
<span class="org-preprocessor">#define</span> <span class="org-function-name">case</span>(<span class="org-variable-name">name</span>)     <span class="org-keyword">case</span> __LINE__: <span class="org-constant">name</span>: _co-&gt;index = __LINE__;

<span class="org-comment-delimiter">/* </span><span class="org-comment">helper</span><span class="org-comment-delimiter"> */</span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">wait</span>(<span class="org-variable-name">time</span>, <span class="org-variable-name">dt</span>) <span class="org-keyword">case</span> __LINE__: _co-&gt;index = __LINE__; _co-&gt;elapsed += dt; <span class="org-keyword">if</span> (_co-&gt;elapsed &lt; time) { <span class="org-keyword">goto</span> <span class="org-constant">_body</span>; } <span class="org-keyword">else</span> { _co-&gt;elapsed = 0; }

<span class="org-type">void</span> <span class="org-function-name">coro_func</span>(<span class="org-type">coroutine_t</span>* <span class="org-variable-name">co</span>) {
    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">i</span> = 2;

    coroutine(co)
    {
        printf(<span class="org-string">"first\n"</span>);
        yield;

        printf(<span class="org-string">"second\n"</span>);
        yield;

        <span class="org-keyword">if</span> (i == 2) { <span class="org-keyword">goto</span> <span class="org-constant">test</span>; }

        <span class="org-keyword">while</span>(1) {
            i--;
            printf(<span class="org-string">"in while\n"</span>);
            <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>i) <span class="org-keyword">break</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">breaking works now</span>
            yield;
        }

        <span class="org-keyword">case</span>(test);
        {
            printf(<span class="org-string">"test case\n"</span>);
            yield;
        }

        wait(1.0f, 0.3f);
        printf(<span class="org-string">"third\n"</span>);
        <span class="org-keyword">goto</span> <span class="org-constant">test</span>;
    }
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">coroutine_t</span> <span class="org-variable-name">co</span> = {0};

    coro_func(&amp;co);
    coro_func(&amp;co);
    coro_func(&amp;co); <span class="org-comment-delimiter">// </span><span class="org-comment">0.3f</span>
    coro_func(&amp;co); <span class="org-comment-delimiter">// </span><span class="org-comment">0.6f</span>
    coro_func(&amp;co); <span class="org-comment-delimiter">// </span><span class="org-comment">0.9f</span>
    coro_func(&amp;co); <span class="org-comment-delimiter">// </span><span class="org-comment">1.2f</span>
    coro_func(&amp;co); <span class="org-comment-delimiter">// </span><span class="org-comment">1.2f</span>
    coro_func(&amp;co); <span class="org-comment-delimiter">// </span><span class="org-comment">1.2f</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org2bec02e" class="outline-3">
<h3 id="org2bec02e"><a href="#org2bec02e">Alternative Macro Implementation</a></h3>
<div class="outline-text-3" id="text-org2bec02e">
<div class="org-src-container">
<pre class="src src-C"><span class="org-comment-delimiter">// </span><span class="org-comment">dependency: sokol_time.h</span>
<span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">Coroutine</span> <span class="org-type">Coroutine</span>;
<span class="org-keyword">struct</span> <span class="org-type">Coroutine</span>
{
    <span class="org-type">S32</span> <span class="org-variable-name">line</span>;
    <span class="org-type">U64</span> <span class="org-variable-name">start_time</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">used for CoroutineWait</span>
    <span class="org-type">void</span>* <span class="org-variable-name">data</span>;
};

<span class="org-preprocessor">#define</span> <span class="org-function-name">CoroutineBegin</span>(<span class="org-variable-name">coro</span>)                 <span class="org-keyword">switch</span> (coro-&gt;line) {<span class="org-keyword">case</span> 0: coro-&gt;line = 0;
<span class="org-preprocessor">#define</span> <span class="org-function-name">CoroutineYield</span>(<span class="org-variable-name">coro</span>)                 <span class="org-keyword">do</span> { coro-&gt;line = __LINE__; <span class="org-keyword">return</span>; <span class="org-keyword">case</span> __LINE__:;} <span class="org-keyword">while</span>(0)
<span class="org-preprocessor">#define</span> <span class="org-function-name">CoroutineYieldUntil</span>(<span class="org-variable-name">coro</span>, <span class="org-variable-name">condition</span>) <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>(condition)) { CoroutineYield(coro); }
<span class="org-preprocessor">#define</span> <span class="org-function-name">CoroutineWait</span>(<span class="org-variable-name">coro</span>, <span class="org-variable-name">duration</span>)        <span class="org-keyword">do</span> {<span class="org-keyword">if</span> (coro-&gt;start_time == 0.0f) { coro-&gt;start_time = stm_now(); } \
                                             CoroutineYieldUntil(coro, stm_sec(stm_now()) &gt; stm_sec(coro-&gt;start_time) + (<span class="org-type">F64</span>)duration); coro-&gt;start_time = 0; } <span class="org-keyword">while</span> (0)
<span class="org-preprocessor">#define</span> <span class="org-function-name">CoroutineEnd</span>(<span class="org-variable-name">coro</span>)                   <span class="org-keyword">do</span> { coro-&gt;line = __LINE__; } <span class="org-keyword">while</span> (0); }
<span class="org-preprocessor">#define</span> <span class="org-function-name">CoroutineReset</span>(<span class="org-variable-name">coro</span>)                 <span class="org-keyword">do</span> { coro-&gt;line = 0; } <span class="org-keyword">while</span> (0); }
<span class="org-preprocessor">#define</span> <span class="org-function-name">CoroutineIsFinished</span>(<span class="org-variable-name">coro</span>)            (coro-&gt;line == -1)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">switch</span> (coro-&gt;line) {<span class="org-keyword">case</span> 0: coro-&gt;line = 0;        <span class="org-comment-delimiter">// </span><span class="org-comment">BEGIN</span>
  coro-&gt;line = __LINE__; <span class="org-keyword">return</span>; <span class="org-keyword">case</span> __LINE__:;    <span class="org-comment-delimiter">// </span><span class="org-comment">YIELD</span>

  <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>(condition)) { CoroutineYield(coro); }    <span class="org-comment-delimiter">// </span><span class="org-comment">YIELD UNTIL</span>

  <span class="org-keyword">if</span> (coro-&gt;start_time == 0.0f) { coro-&gt;start_time = stm_now(); }  <span class="org-comment-delimiter">// </span><span class="org-comment">WAIT</span>
  CoroutineYieldUntil(coro, stm_sec(stm_now()) &gt; stm_sec(coro-&gt;start_time) + (<span class="org-type">F64</span>)duration);
  coro-&gt;start_time = 0;

coro-&gt;line = __LINE__; }                            <span class="org-comment-delimiter">// </span><span class="org-comment">END or..</span>
coro-&gt;line = 0; }                                   <span class="org-comment-delimiter">// </span><span class="org-comment">...RESET</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org258a53e" class="outline-3">
<h3 id="org258a53e"><a href="#org258a53e">More Elaborate Macro Implementation</a></h3>
<div class="outline-text-3" id="text-org258a53e">
<p>
<a href="https://github.com/RandyGaul/kk_slides/blob/master/src/cute_coroutine.h">This implementation</a> allows for every coroutine to have its own stack and
allocate local variables from it and can allow nested coroutine (i.e a function
using a coroutine passes that coroutine to another function using coroutines).
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span>
{
    <span class="org-type">float</span> <span class="org-variable-name">elapsed</span>;                     <span class="org-comment-delimiter">// </span><span class="org-comment">timer</span>
    <span class="org-type">int</span> <span class="org-variable-name">flag</span>;                          <span class="org-comment-delimiter">// </span><span class="org-comment">?</span>
    <span class="org-type">int</span> <span class="org-variable-name">index</span>;                         <span class="org-comment-delimiter">// </span><span class="org-comment">code-line &amp; case-label</span>
<span class="org-preprocessor">    #define</span> <span class="org-variable-name">COROUTINE_MAX_DEPTH</span> 8      <span class="org-comment-delimiter">// </span><span class="org-comment">how deep into nested coroutines we go</span>
    <span class="org-type">int</span> <span class="org-variable-name">line</span>[COROUTINE_MAX_DEPTH];     <span class="org-comment-delimiter">// </span><span class="org-comment">keeps track of the sequence point of nested coroutines</span>
    <span class="org-type">int</span> <span class="org-variable-name">stack_pointer</span>;                 <span class="org-comment-delimiter">// </span><span class="org-comment">used for pushing on to the stack</span>
<span class="org-preprocessor">    #define</span> <span class="org-variable-name">COROUTINE_STACK_SIZE</span> (512) <span class="org-comment-delimiter">// </span><span class="org-comment">static stack size for every coroutine</span>
    <span class="org-type">char</span> <span class="org-variable-name">stack</span>[COROUTINE_STACK_SIZE];  <span class="org-comment-delimiter">// </span><span class="org-comment">the stack, usage optional</span>
} <span class="org-type">coroutine_t</span>;

<span class="org-preprocessor">#define</span> <span class="org-variable-name">COROUTINE_CASE_OFFSET</span> (1024 * 1024)

<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">coroutine_init</span>(<span class="org-type">coroutine_t</span>* <span class="org-variable-name">co</span>) <span class="org-comment-delimiter">/* </span><span class="org-comment">Just zero out the coroutine</span><span class="org-comment-delimiter"> */</span>
{
    co-&gt;elapsed = 0; co-&gt;flag = 0; co-&gt;index = 0;
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; COROUTINE_MAX_DEPTH; ++i) co-&gt;line[i] = 0;
    co-&gt;stack_pointer = 0;
}

<span class="org-doc">/**</span>
<span class="org-doc"> * Pops off `size` bytes from `co`'s fixed-size buffer for use as a local variable.</span>
<span class="org-doc"> *</span>
<span class="org-doc"> * void do_work(coroutine_t* co)</span>
<span class="org-doc"> * {</span>
<span class="org-doc"> *     int* a = (int*)coroutine_local_var(co, sizeof(int));</span>
<span class="org-doc"> *     int* b = (int*)coroutine_local_var(co, sizeof(int));</span>
<span class="org-doc"> *</span>
<span class="org-doc"> *     COROUTINE_START(co); // Setup initial values here. This code runs just once.</span>
<span class="org-doc"> *     *a = 3; *b = 7;</span>
<span class="org-doc"> *     // ...</span>
<span class="org-doc"> *     COROUTINE_END(co);</span>
<span class="org-doc"> * }</span>
<span class="org-doc"> */</span>
<span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-type">void</span>* <span class="org-function-name">coroutine_local_var</span>(<span class="org-type">coroutine_t</span>* <span class="org-variable-name">co</span>, <span class="org-type">int</span> <span class="org-variable-name">size</span>)
{
    COROUTINE_ASSERT(co-&gt;stack_pointer + size &lt; COROUTINE_STACK_SIZE);
    <span class="org-type">void</span>* <span class="org-variable-name">ptr</span> = co-&gt;stack + co-&gt;stack_pointer;
    co-&gt;stack_pointer += (<span class="org-type">int</span>)size;
    <span class="org-keyword">return</span> ptr;
}

<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_START</span>(<span class="org-variable-name">co</span>)          <span class="org-keyword">do</span> { co-&gt;flag = 0; <span class="org-keyword">switch</span> (co-&gt;line[co-&gt;index]) { <span class="org-keyword">default</span>: <span class="org-comment-delimiter">/* </span><span class="org-comment">default is 0, and will run just once.</span><span class="org-comment-delimiter"> */</span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_CASE</span>(<span class="org-variable-name">co</span>, <span class="org-variable-name">name</span>)     <span class="org-keyword">case</span> __LINE__: <span class="org-constant">name</span>: co-&gt;line[co-&gt;index] = __LINE__;
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_WAIT</span>(<span class="org-variable-name">co</span>, <span class="org-variable-name">time</span>, <span class="org-variable-name">dt</span>) <span class="org-keyword">do</span> { <span class="org-keyword">case</span> __LINE__: co-&gt;line[co-&gt;index] = __LINE__; co-&gt;elapsed += dt; <span class="org-keyword">do</span> { <span class="org-keyword">if</span> (co-&gt;elapsed &lt; time) { co-&gt;flag = 1; <span class="org-keyword">goto</span> <span class="org-constant">__co_end</span>; } <span class="org-keyword">else</span> { co-&gt;elapsed = 0; } } <span class="org-keyword">while</span> (0); } <span class="org-keyword">while</span> (0)
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_EXIT</span>(<span class="org-variable-name">co</span>)           <span class="org-keyword">do</span> { co-&gt;flag = 1; <span class="org-keyword">goto</span> <span class="org-constant">__co_end</span>; } <span class="org-keyword">while</span> (0)
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_YIELD</span>(<span class="org-variable-name">co</span>)          <span class="org-keyword">do</span> { co-&gt;line[co-&gt;index] = __LINE__; COROUTINE_EXIT(co); <span class="org-keyword">case</span> __LINE__:; } <span class="org-keyword">while</span> (0)
<span class="org-comment-delimiter">/* </span><span class="org-comment">COROUTINE_CALL(co, call_some_other_func(co, my_params));</span><span class="org-comment-delimiter"> */</span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_CALL</span>(<span class="org-variable-name">co</span>, ...)      co-&gt;flag = 0; <span class="org-keyword">case</span> __LINE__: COROUTINE_ASSERT(co-&gt;index &lt; COROUTINE_MAX_DEPTH); co-&gt;line[co-&gt;index++] = __LINE__; __VA_ARGS__; co-&gt;index--; <span class="org-keyword">do</span> { <span class="org-keyword">if</span> (co-&gt;flag) { <span class="org-keyword">goto</span> <span class="org-constant">__co_end</span>; } <span class="org-keyword">else</span> { <span class="org-keyword">case</span> __LINE__ + COROUTINE_CASE_OFFSET: co-&gt;line[co-&gt;index] = __LINE__ + COROUTINE_CASE_OFFSET; } } <span class="org-keyword">while</span> (0)
<span class="org-preprocessor">#define</span> <span class="org-function-name">COROUTINE_END</span>(<span class="org-variable-name">co</span>)            } co-&gt;line[co-&gt;index] = 0; <span class="org-constant">__co_end</span>:; co-&gt;stack_pointer = 0; } <span class="org-keyword">while</span> (0)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga6e6d22" class="outline-2">
<h2 id="orga6e6d22"><a href="#orga6e6d22">Coroutines in C using <code>setjmp</code></a></h2>
<div class="outline-text-2" id="text-orga6e6d22">
<p>
<a href="https://250bpm.com/blog:48">https://250bpm.com/blog:48</a>
</p>

<div class="org-src-container">
<pre class="src src-C" id="coroutine.h"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;setjmp.h&gt;</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">STACK_SIZE</span> 16384

<span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">unoptimisable_</span> = 1;

<span class="org-keyword">struct</span> <span class="org-type">cr_</span> {
    <span class="org-keyword">struct</span> <span class="org-type">cr_</span> *<span class="org-variable-name">next</span>;
    <span class="org-type">jmp_buf</span> <span class="org-variable-name">ctx</span>;
};

<span class="org-keyword">struct</span> <span class="org-type">cr_</span> <span class="org-variable-name">main_cr_</span> = {<span class="org-constant">NULL</span>};

<span class="org-keyword">struct</span> <span class="org-type">cr_</span> *<span class="org-variable-name">first_cr_</span> = &amp;main_cr_;
<span class="org-keyword">struct</span> <span class="org-type">cr_</span> *<span class="org-variable-name">last_cr_</span> = &amp;main_cr_;

<span class="org-preprocessor">#define</span> <span class="org-function-name">go</span>(<span class="org-variable-name">fn</span>) \
    <span class="org-keyword">do</span> {\
        <span class="org-keyword">if</span>(<span class="org-negation-char">!</span>setjmp(first_cr_-&gt;ctx)) {\
            <span class="org-type">char</span> *<span class="org-variable-name">stack</span> = malloc(STACK_SIZE);\
            <span class="org-type">int</span> <span class="org-variable-name">anchor_</span>[unoptimisable_];\
            <span class="org-type">char</span> <span class="org-variable-name">filler_</span>[(<span class="org-type">char</span>*)&amp;anchor_ - (<span class="org-type">char</span>*)(stack + STACK_SIZE)];\
            <span class="org-keyword">struct</span> <span class="org-type">cr_</span> <span class="org-variable-name">cr</span>[unoptimisable_];\
            cr-&gt;next = first_cr_;\
            first_cr_ = cr;\
            <span class="org-type">char</span> *<span class="org-variable-name">stack_</span>[unoptimisable_];\
            stack_[0] = stack;\
            fn;\
            free(stack_[0]);\
            first_cr_ = first_cr_-&gt;next;\
            longjmp(first_cr_-&gt;ctx, 1);\
        }\
    } <span class="org-keyword">while</span>(0)

<span class="org-type">void</span> <span class="org-function-name">yield</span>(<span class="org-type">void</span>) {
    <span class="org-keyword">if</span>(first_cr_ == last_cr_)
        <span class="org-keyword">return</span>;
    <span class="org-keyword">if</span>(setjmp(first_cr_-&gt;ctx))
        <span class="org-keyword">return</span>;
    <span class="org-keyword">struct</span> <span class="org-type">cr_</span> *<span class="org-variable-name">cr</span> = first_cr_;
    first_cr_ = cr-&gt;next;
    cr-&gt;next = <span class="org-constant">NULL</span>;
    last_cr_-&gt;next = cr;
    last_cr_ = cr;
    longjmp(first_cr_-&gt;ctx, 1);
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;setjmp.h&gt;</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">STACK_SIZE</span> 16384

<span class="org-keyword">volatile</span> <span class="org-type">int</span> <span class="org-variable-name">unoptimisable_</span> = 1;

<span class="org-keyword">struct</span> <span class="org-type">cr_</span> {
    <span class="org-keyword">struct</span> <span class="org-type">cr_</span> *<span class="org-variable-name">next</span>;
    <span class="org-type">jmp_buf</span> <span class="org-variable-name">ctx</span>;
};

<span class="org-keyword">struct</span> <span class="org-type">cr_</span> <span class="org-variable-name">main_cr_</span> = {<span class="org-constant">NULL</span>};

<span class="org-keyword">struct</span> <span class="org-type">cr_</span> *<span class="org-variable-name">first_cr_</span> = &amp;main_cr_;
<span class="org-keyword">struct</span> <span class="org-type">cr_</span> *<span class="org-variable-name">last_cr_</span> = &amp;main_cr_;

<span class="org-preprocessor">#define</span> <span class="org-function-name">go</span>(<span class="org-variable-name">fn</span>) \
    <span class="org-keyword">do</span> {\
        <span class="org-keyword">if</span>(<span class="org-negation-char">!</span>setjmp(first_cr_-&gt;ctx)) {\
            <span class="org-type">char</span> *<span class="org-variable-name">stack</span> = malloc(STACK_SIZE);\
            <span class="org-type">int</span> <span class="org-variable-name">anchor_</span>[unoptimisable_];\
            <span class="org-type">char</span> <span class="org-variable-name">filler_</span>[(<span class="org-type">char</span>*)&amp;anchor_ - (<span class="org-type">char</span>*)(stack + STACK_SIZE)];\
            <span class="org-keyword">struct</span> <span class="org-type">cr_</span> <span class="org-variable-name">cr</span>[unoptimisable_];\
            cr-&gt;next = first_cr_;\
            first_cr_ = cr;\
            <span class="org-type">char</span> *<span class="org-variable-name">stack_</span>[unoptimisable_];\
            stack_[0] = stack;\
            fn;\
            free(stack_[0]);\
            first_cr_ = first_cr_-&gt;next;\
            longjmp(first_cr_-&gt;ctx, 1);\
        }\
    } <span class="org-keyword">while</span>(0)

<span class="org-type">void</span> <span class="org-function-name">yield</span>(<span class="org-type">void</span>) {
    <span class="org-keyword">if</span>(first_cr_ == last_cr_)
        <span class="org-keyword">return</span>;
    <span class="org-keyword">if</span>(setjmp(first_cr_-&gt;ctx))
        <span class="org-keyword">return</span>;
    <span class="org-keyword">struct</span> <span class="org-type">cr_</span> *<span class="org-variable-name">cr</span> = first_cr_;
    first_cr_ = cr-&gt;next;
    cr-&gt;next = <span class="org-constant">NULL</span>;
    last_cr_-&gt;next = cr;
    last_cr_ = cr;
    longjmp(first_cr_-&gt;ctx, 1);
}

<span class="org-type">void</span> <span class="org-function-name">foo</span>(<span class="org-type">int</span> <span class="org-variable-name">count</span>, <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">text</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
    <span class="org-keyword">for</span>(i = 0; i != count; ++i) {
        printf(<span class="org-string">"%s\n"</span>, text);
        yield();
    }
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    go(foo(3, <span class="org-string">"a"</span>));
    go(printf(<span class="org-string">"Hello, %s!\n"</span>, <span class="org-string">"world"</span>));
    go(foo(2, <span class="org-string">"b"</span>));
    foo(5, <span class="org-string">"c"</span>);
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org58fbe77" class="outline-2">
<h2 id="org58fbe77"><a href="#org58fbe77">Coroutines using Memory Arenas</a></h2>
<div class="outline-text-2" id="text-org58fbe77">
<p>
Coroutine stack in back-buffered <a href="arena.html#ID-7629c564-ec09-4a74-be59-32e6bf702e31">frame arena</a>
</p>
<ul class="org-ul">
<li>probably need to pass in curr and prev frame arena</li>
<li>need to juggle stack between the two after each yield</li>
<li>maybe could be integrated into the coroutine macros</li>
<li>actually, do the juggle before coroutine<sub>begin</sub> in a macro</li>
</ul>

<p>
every coroutine has its own subarena
</p>
<ul class="org-ul">
<li>needs to clear arena after return</li>
<li>means every coroutine needs an init where arena is alloc'ed</li>
</ul>
</div>
</div>
<div id="outline-container-orge42a995" class="outline-2">
<h2 id="orge42a995"><a href="#orge42a995">Resources</a></h2>
<div class="outline-text-2" id="text-orge42a995">
<ul class="org-ul">
<li>Macro-based C Implementations
<ul class="org-ul">
<li><a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">Coroutines in C using Duff's Device</a></li>
<li><a href="https://github.com/RandyGaul/kk_slides/blob/master/slides/coroutine.h">Minimal Macro-based Implementation of Coroutines in C</a></li>
<li><a href="https://github.com/bigrando420/thomas/blob/main/sauce/th_coroutine.h">https://github.com/bigrando420/thomas/blob/main/sauce/th_coroutine.h</a></li>
<li><a href="https://kihlander.net/post/protothreads-with-a-twist/">Protothreads with a twist</a></li>
<li><a href="https://github.com/RandyGaul/cute_framework/blob/master/include/cute_routine.h">cute<sub>routine.h</sub> - C++ Coroutines</a></li>
<li><a href="https://gist.github.com/NoelFB/7a5fa66fc29dd7ed1c11042c30f1b00e">routine.h</a></li>
<li><a href="https://github.com/codr7/hacktical-c/tree/main/task">Lightweight Concurrent Tasks in C</a></li>
<li><a href="https://github.com/liuliu/co/blob/master/co.h">Stackless Coroutine in C That Maintains Local Variables</a></li>
</ul></li>

<li><a href="https://www.youtube.com/watch?v=tGbzUjUiCsE">Video: Juggling Coroutine State between two Frame Arenas</a></li>

<li>Cute Framework Coroutines
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=MuCpdoIEpgA">Video: Demonstration of Coroutines in C</a></li>
<li><a href="https://randygaul.github.io/cute_framework/#/topics/coroutines">Cute Framework Coroutines Explanation</a></li>
<li><a href="https://github.com/RandyGaul/cute_framework/blob/master/src/cute_coroutine.cpp">cute<sub>coroutine.cpp</sub></a></li>
<li><a href="https://github.com/RandyGaul/kk_slides/blob/master/src/cute_coroutine.h">https://github.com/RandyGaul/kk_slides/blob/master/src/cute_coroutine.h</a></li>
<li><a href="https://randygaul.github.io/cute_framework/#/topics/coroutines">CF Coroutine</a></li>
</ul></li>

<li><a href="https://github.com/hnes/libaco">Libaco</a>: Records entire stack frames (real local variables)</li>
<li><a href="https://github.com/edubart/minicoro">minicoro</a>: Stackful asymmetric coroutines via assembly, ucontext or fibers</li>
<li><a href="https://github.com/RandyGaul/cute_framework/blob/master/include/cute_coroutine.h">cute<sub>coroutine.h</sub></a>: Coroutine implementation using minicoro</li>
<li><a href="https://www.lua.org/pil/9.1.html">Lua Coroutine Basics</a></li>
<li><a href="https://edw.is/how-to-implement-action-sequences-and-cutscenes/">Implementing Action Sequences and Cutscenes with Lua Coroutines</a></li>
<li><a href="https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/coroutines-philosophy/">Philosophy of coroutines</a></li>
</ul>
</div>
</div>
<div id="footnotes">
<h3 class="footnotes">Footnotes</h3>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="https://eli.thegreenplace.net/2009/08/29/co-routines-as-an-alternative-to-state-machines/">Co-routines as an alternative to state machines</a>
</p></div></div>


</div>
</div></main>
</body>
</html>
